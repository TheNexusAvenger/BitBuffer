local function trim(str)
	local lowerBound = 1
	local upperBound = #str
	local pattern = "[%s\r\n\t]"

	for i = 1, upperBound do
		if string.match(string.sub(str, i, i), pattern) then
			lowerBound = i + 1
		else
			break
		end
	end

	for i = upperBound, lowerBound, -1 do
		if string.match(string.sub(str, i, i), pattern) then
			upperBound = i - 1
		else
			break
		end
	end

	return string.sub(str, lowerBound, upperBound)
end

local function format(base, formatArgs)
	return string.gsub(base, "%$(%b{})", function(argName)
		argName = string.match(argName, "{(%w-)}")
		local arg = formatArgs[argName]
		if arg == nil then
			error(string.format("Missing format argument '%s'.", argName))
		end

		return arg
	end)
end

local function identity(value)
	return function()
		return value
	end
end

local function withIndent(str, indent)
	return string.gsub(str, "\n", function()
		return "\n" .. string.rep("\t", indent)
	end)
end

local function BenchmarkFile(authorName)
	return {
		AuthorName = authorName; -- self-descriptive
		ConstructorSyntax = nil; -- syntax used to construct the bitbuffer from its module: () or .new()
		ReadMethodSyntax = nil; -- syntax used for read methods, :read, :Read, .read, etc...
		WriteMethodSyntax = nil; -- same but for write
		ResetCursorSyntax = nil; -- method syntax to reset the buffer's cursor, :ResetCursor()

		-- Method name + parameters syntax template for Write for each types
		-- Int(16, @)
		-- Int16(@)
		-- etc...
		-- @ is replaced with the actual input
		-- concatenated with Read/WriteMethodSyntax
		WriteTypeTemplates = nil;

		-- Method name + parameters syntax template for Read for each types
		-- !no input!
		ReadTypeTemplates = nil;

		-- target utils/RandomGenerator function for each types.
		RandomInputKinds = nil;

		-- self-descriptive. For each types.
		IterationCounts = nil;
	}
end

local FileBase = {
	TopLevel = trim([[
-- this script was @generated by generate.lua and is not meant for manual editing.
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local BitBufferModule = require(ReplicatedStorage.BitBuffers.${BitBufferName})
local RandomGenerator = require(ReplicatedStorage.Utils.RandomGenerator)
	]]);

	ReturnStatement = trim([[
return {${ReturnBody}}
	]]);

	SingleBenchmark = trim([[
${BenchmarkName} = {
	ParameterGenerator = function(seed)
		local r = RandomGenerator.${RandomInputKind}(seed, ${IterationCount})
		return BitBufferModule${Constructor}, r
	end;
	Write = function(bitbuffer, inputs)
		for i = 1, ${IterationCount} do
			bitbuffer${WriteMethod}
		end
	end;
	ResetCursor = function(bitbuffer)
		bitbuffer${ResetCursor}
	end;
	Read = function(bitbuffer)
		for _ = 1, ${IterationCount} do
			bitbuffer${ReadMethod}
		end
	end;
};
	]]);
}

local function GenerateFile(benchmarkFile, target)
	local filename = string.format("%s.lua", benchmarkFile.AuthorName)
	local top = format(FileBase.TopLevel, {
		BitBufferName = benchmarkFile.AuthorName;
	})

	local bodies = {}
	for benchmarkedType, writeTypeTemplate in next, benchmarkFile.WriteTypeTemplates do
		local readTypeTemplate = benchmarkFile.ReadTypeTemplates[benchmarkedType]
		local randomInputKind = benchmarkFile.RandomInputKinds[benchmarkedType]
		local iterationCount = benchmarkFile.IterationCounts[benchmarkedType]

		local benchmarkBody = format(FileBase.SingleBenchmark, {
			BenchmarkName = benchmarkedType;
			RandomInputKind = randomInputKind;
			IterationCount = iterationCount;
			Constructor = benchmarkFile.ConstructorSyntax;
			ResetCursor = benchmarkFile.ResetCursorSyntax;
			WriteMethod = benchmarkFile.WriteMethodSyntax .. string.gsub(writeTypeTemplate, "@", identity("inputs[i]"));
			ReadMethod = benchmarkFile.ReadMethodSyntax .. readTypeTemplate;
		})

		table.insert(bodies, withIndent("\n" .. benchmarkBody, 1) .. "\n")
	end

	local fileContent = top .. "\n\n" .. format(FileBase.ReturnStatement, {
		ReturnBody = table.concat(bodies);
	}) .. "\n"

	-- selene: allow(global_usage)
	local io = _G.io -- silence robloxLsp/selene warnings
	local file = assert(io.open(string.format("%s/benchmarks/%s", target, filename), "w"))
	file:write(fileContent)
	file:close()
end

local ITERATION_COUNT_INTS = 1024
local ITERATION_COUNT_STRINGS = 128

local Anaminus = BenchmarkFile("Anaminus")
Anaminus.ConstructorSyntax = ".new()"
Anaminus.ReadMethodSyntax = ":Read"
Anaminus.WriteMethodSyntax = ":Write"
Anaminus.ResetCursorSyntax = ":SetIndex(0)"
Anaminus.WriteTypeTemplates = {
	Int16 = "Int(16, @)";
	Int32 = "Int(32, @)";
	UInt16 = "Uint(16, @)";
	UInt32 = "Uint(32, @)";
	StringL10 = nil;
	StringL100 = nil;
	StringL1000 = nil;
	BytesL10 = "Bytes(@)";
	BytesL100 = "Bytes(@)";
	BytesL1000 = "Bytes(@)";
	Bool = "Bool(@)";
	Float32 = "Float(32, @)";
	Float64 = "Float(64, @)";
	Char = "Byte(string.byte(@))";
}
Anaminus.ReadTypeTemplates = {
	Int16 = "Int(16)";
	Int32 = "Int(32)";
	UInt16 = "Uint(32)";
	UInt32 = "Uint(32)";
	StringL10 = nil;
	StringL100 = nil;
	StringL1000 = nil;
	BytesL10 = "Bytes(10)";
	BytesL100 = "Bytes(100)";
	BytesL1000 = "Bytes(1000)";
	Bool = "Bool()";
	Float32 = "Float(32)";
	Float64 = "Float(64)";
	Char = "Byte()";
}
Anaminus.RandomInputKinds = {
	Int16 = "Int16";
	Int32 = "Int32";
	UInt16 = "UInt16";
	UInt32 = "UInt32";
	StringL10 = nil;
	StringL100 = nil;
	StringL1000 = nil;
	BytesL10 = "Bytes10";
	BytesL100 = "Bytes100";
	BytesL1000 = "Bytes1000";
	Bool = "Bool";
	Float32 = "Float";
	Float64 = "Float";
	Char = "Char";
}
Anaminus.IterationCounts = {
	Int16 = ITERATION_COUNT_INTS;
	Int32 = ITERATION_COUNT_INTS;
	UInt16 = ITERATION_COUNT_INTS;
	UInt32 = ITERATION_COUNT_INTS;
	StringL10 = nil;
	StringL100 = nil;
	StringL1000 = nil;
	BytesL10 = ITERATION_COUNT_STRINGS;
	BytesL100 = ITERATION_COUNT_STRINGS;
	BytesL1000 = ITERATION_COUNT_STRINGS;
	Bool = ITERATION_COUNT_INTS;
	Float32 = ITERATION_COUNT_INTS;
	Float64 = ITERATION_COUNT_INTS;
	Char = ITERATION_COUNT_INTS;
}

local rstk = BenchmarkFile("rstk")
rstk.ConstructorSyntax = ".new()"
rstk.ReadMethodSyntax = ":Read"
rstk.WriteMethodSyntax = ":Write"
rstk.ResetCursorSyntax = ":ResetCursor()"
rstk.WriteTypeTemplates = {
	Int16 = "Int(16, @)";
	Int32 = "Int(32, @)";
	UInt16 = "UInt(16, @)";
	UInt32 = "UInt(32, @)";
	StringL10 = "String(@)";
	StringL100 = "String(@)";
	StringL1000 = "String(@)";
	BytesL10 = "Bytes(@)";
	BytesL100 = "Bytes(@)";
	BytesL1000 = "Bytes(@)";
	Bool = "Bool(@)";
	Float32 = "Float32(@)";
	Float64 = "Float64(@)";
	Char = "Char(@)";
}
rstk.ReadTypeTemplates = {
	Int16 = "Int(16)";
	Int32 = "Int(32)";
	UInt16 = "UInt(32)";
	UInt32 = "UInt(32)";
	StringL10 = "String()";
	StringL100 = "String()";
	StringL1000 = "String()";
	BytesL10 = "Bytes(10)";
	BytesL100 = "Bytes(100)";
	BytesL1000 = "Bytes(1000)";
	Bool = "Bool()";
	Float32 = "Float32()";
	Float64 = "Float64()";
	Char = "Char()";
}
rstk.RandomInputKinds = {
	Int16 = "Int16";
	Int32 = "Int32";
	UInt16 = "UInt16";
	UInt32 = "UInt32";
	StringL10 = "Bytes10";
	StringL100 = "Bytes100";
	StringL1000 = "Bytes1000";
	BytesL10 = "Bytes10";
	BytesL100 = "Bytes100";
	BytesL1000 = "Bytes1000";
	Bool = "Bool";
	Float32 = "Float";
	Float64 = "Float";
	Char = "Char";
}
rstk.IterationCounts = {
	Int16 = ITERATION_COUNT_INTS;
	Int32 = ITERATION_COUNT_INTS;
	UInt16 = ITERATION_COUNT_INTS;
	UInt32 = ITERATION_COUNT_INTS;
	StringL10 = ITERATION_COUNT_STRINGS;
	StringL100 = ITERATION_COUNT_STRINGS;
	StringL1000 = ITERATION_COUNT_STRINGS;
	BytesL10 = ITERATION_COUNT_STRINGS;
	BytesL100 = ITERATION_COUNT_STRINGS;
	BytesL1000 = ITERATION_COUNT_STRINGS;
	Bool = ITERATION_COUNT_INTS;
	Float32 = ITERATION_COUNT_INTS;
	Float64 = ITERATION_COUNT_INTS;
	Char = ITERATION_COUNT_INTS;
}

local Dekkonot = BenchmarkFile("Dekkonot")
Dekkonot.ConstructorSyntax = "()"
Dekkonot.ReadMethodSyntax = ".read"
Dekkonot.WriteMethodSyntax = ".write"
Dekkonot.ResetCursorSyntax = ".setPointer(0)"
Dekkonot.WriteTypeTemplates = {
	Int16 = "Signed(16, @)";
	Int32 = "Signed(32, @)";
	UInt16 = "Unsigned(16, @)";
	UInt32 = "Unsigned(32, @)";
	StringL10 = "String(@)";
	StringL100 = "String(@)";
	StringL1000 = "String(@)";
	BytesL10 = nil;
	BytesL100 = nil;
	BytesL1000 = nil;
	Bool = "Bits(if @ == true then 1 else 0)";
	Float32 = "Float32(@)";
	Float64 = "Float64(@)";
	Char = "Byte(string.byte(@))";
}
Dekkonot.ReadTypeTemplates = {
	Int16 = "Signed(16)";
	Int32 = "Signed(32)";
	UInt16 = "Unsigned(16)";
	UInt32 = "Unsigned(32)";
	StringL10 = "String()";
	StringL100 = "String()";
	StringL1000 = "String()";
	BytesL10 = nil;
	BytesL100 = nil;
	BytesL1000 = nil;
	Bool = "Bits(1)";
	Float32 = "Float32()";
	Float64 = "Float64()";
	Char = "Byte()";
}
Dekkonot.RandomInputKinds = {
	Int16 = "Int16";
	Int32 = "Int32";
	UInt16 = "UInt16";
	UInt32 = "UInt32";
	StringL10 = "Bytes10";
	StringL100 = "Bytes100";
	StringL1000 = "Bytes1000";
	BytesL10 = nil;
	BytesL100 = nil;
	BytesL1000 = nil;
	Bool = "Bool";
	Float32 = "Float";
	Float64 = "Float";
	Char = "Char";
}
Dekkonot.IterationCounts = {
	Int16 = ITERATION_COUNT_INTS;
	Int32 = ITERATION_COUNT_INTS;
	UInt16 = ITERATION_COUNT_INTS;
	UInt32 = ITERATION_COUNT_INTS;
	StringL10 = ITERATION_COUNT_STRINGS;
	StringL100 = ITERATION_COUNT_STRINGS;
	StringL1000 = ITERATION_COUNT_STRINGS;
	BytesL10 = nil;
	BytesL100 = nil;
	BytesL1000 = nil;
	Bool = ITERATION_COUNT_INTS;
	Float32 = ITERATION_COUNT_INTS;
	Float64 = ITERATION_COUNT_INTS;
	Char = ITERATION_COUNT_INTS;
}

-- selene: allow(global_usage)
local spawn = _G.os.execute

spawn("mkdir benchmarks/generated/")
spawn("mkdir benchmarks/generated/benchmarks")
spawn("mkdir benchmarks/generated/bitbuffers")

local Links = {
	Anaminus = "https://raw.githubusercontent.com/Anaminus/roblox-library/master/modules/Bitbuf/Bitbuf.lua";
	Dekkonot = "https://raw.githubusercontent.com/Dekkonot/bitbuffer/main/src/roblox.lua";
	rstk = "https://raw.githubusercontent.com/rstk/BitBuffer/master/src/init.lua";
}

spawn("curl " .. Links.Dekkonot .. " --output benchmarks/generated/bitbuffers/Dekkonot.lua")
spawn("curl " .. Links.Anaminus .. " --output benchmarks/generated/bitbuffers/Anaminus.lua")
spawn("curl " .. Links.rstk .. " --output benchmarks/generated/bitbuffers/rstk.lua")
-- downloads latest BitBuffer instead of using local one; it may be better to use the local one but then i'd need to depend
-- on some external lua library or detect which OS is used to use the correct copy command and i'm not doing that :p
-- let users modify this script

GenerateFile(Anaminus, "benchmarks/generated")
GenerateFile(Dekkonot, "benchmarks/generated")
GenerateFile(rstk, "benchmarks/generated")

print("Finished generating benchmarks")
